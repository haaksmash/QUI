% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode
\documentclass{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

 \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float

\usepackage[usenames,dvipsnames]{color}
\usepackage{textcomp}
\usepackage{listings}
\lstset{ 
language=Python,                % choose the language of the code
basicstyle=\scriptsize,       % the size of the fonts that are used for the code
identifierstyle=\ttfamily,
numbers=left,                   % where to put the line-numbers
numberstyle=\ttfamily,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=2pt,                  % how far the line-numbers are from the code
backgroundcolor=\color[rgb]{0.95,.95,.95},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
%frame=single,   		% adds a frame around the code
tabsize=2,  		% sets default tabsize to 2 spaces
captionpos=b,   		% sets the caption-position to bottom
breaklines=true,    	% sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%}{)},          % if you want to add a comment within your code
upquote=true,
keywordstyle=\color{blue}\ttfamily,
commentstyle=\ttfamily\color{ForestGreen},
stringstyle=\color{red}\ttfamily,
upquote=true
}

\makeatletter
\lst@AddToHook{TextStyle}{\let\lst@basicstyle\ttfamily\normalsize\fontfamily{pcr}\selectfont}
\makeatother

\newcommand{\il}[1]{\lstinline{#1}}
\newcommand{\lstslice}[3]{
\begin{center}
\begin{minipage}{0.85\textwidth}
\lstinputlisting[linerange={#1-#2}, firstnumber=#1]{#3}
\end{minipage}
\end{center}
}
\usepackage{xargs}
\newcommandx{\lstdump}[3][1=1,2=No Caption]{
\begin{center}
\begin{minipage}{0.85\textwidth}
\newcommand{\storelstname}{\lstlistingname}
\newcommand{\storelstlisting}{\thelstlisting}
\renewcommand{\lstlistingname}{#1}
\renewcommand{\thelstlisting}{}
\lstinputlisting[caption=#2, ]{#3}
\renewcommand{\lstlistingname}{\storelstname}
\renewcommand{\thelstlisting}{\storelstlisting}
\end{minipage}
\end{center}
}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{QUI}\chead{}\rhead{J.H., H.S.}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Query Universal Interface}
\author{Haak Saxberg and Jess Hester}
\date{December 9, 2011}

\begin{document}
\maketitle
\newpage
\tableofcontents

\newpage
\section{Introduction}
The need to store persistent data is a headache for many developers. Often, they encounter this problem early on, and due to time
or budget pressure, their solution is necessarily tailored to the current realities of their applications -- with a limited view, if any, of 
their application's future, scaled-up needs.

This makes transporting an application from one storage engine to another a time-consuming and expensive affair; all too often, the
costs associated with the migration prevent the application from migrating for an extended period of time, which generally means that
users aren't getting 100\% use.

In the past, this issue was annoying but manageable, since persistent storage was frequently implemented using relational databases.
By the mid 90's, nearly all relational databases were mostly SQL-compliant. Every vendor, of course, had their own flavor of SQL which
presented the eternal threat that a critical query wouldn't run on a new database, but for the most part SQL was SQL.

In the modern era, companies are increasingly looking to non-relational databases as storage solutions, because they can be scaled up
much more cost-effectively and quickly -- a must in today's data-driven business world. However, non-relational databases don't yet have
a common language like SQL; one database's SELECT could very well be another's INSERT.

Enter the Query Universal Interface (QUI).

QUI attempts to ease the transition between non-relational databases, like other ORMs do for relational databases. QUI does not pretend
to implement a universal querying syntax, but rather a universal interface through which code can talk to data with minimal, if any, change.

\section{Language Overview}
\subsection{Basic Computation}
At its heart, QUI is a translation engine. It converts class-like data into a form that is understandable to a backend's API.
\subsection{Basic Data Structures}
QUI has two foundational elements: Models and Fields. 
\subsection{Basic Control Structures}
Users can fine-tune their interactions with their databases in a couple of ways:
\begin{enumerate}
\item Trivially, by passing in configuration arguments to the pre-created Field subclasses
\item Defining their own fields, with custom behaviors
\item Defining their own FieldMixins, customizing their interaction with data
\item Defining their own ModelMixins, customizing their interaction with the databases
\end{enumerate}

\subsection{Input/Output}

\subsection{Error Handling}
QUI provides support for robust error handling at several levels.

\subsection{Tool Support}


\subsection{Alternatives to QUI}
There are a few interfaces which share a common purpose with QUI -- the universalization of database access. None, however,
make it their focus to unify \emph{non-relational} databases. Packages like SQLAlchemy and Django's proprietary ORM work to
universalize access to many SQL-based relational databases, but neither officially supports non-relational databases of any sort.\\

QUI attempts to address an untapped niche market; its declared purpose is unique amongst ORMs.

\section{Example Programs}
\subsection{Model Definition}
Here's what it might look like if you wanted to define a simple model:
\lstdump[test.py][defining a simple model]{model_definitions.py}

Let's step through this definition. First, we import the necesassary things from qui:
\lstslice{1}{3}{model_definitions.py}
\il{qui.fields} contains all the supported field types, like \il{StringField, IntegerField}, etc. At the moment, QUI supports 
a bare minimum of fields - just the most basic types.

Next, we decorate the class with \il{storage()}:

\lstslice{5}{6}{model_definitions.py}

the \il{backend} keyword argument to the \il{storage} decorator tells QUI which mixins it needs to add to your model's inheritance tree,
as well as the inheritance trees of any \il{Fields} you've defined for the model. \il{storage} will accept arbitrary keyword arguments,
but only acts on a few:
\begin{enumerate}
	\item \il{backend}, which defaults to \il{None} and will (generally) raise an \il{ImproperlyConfigured} exception if not defined, or
	if you pass in a backend-identifying string that isn't recognized.
	\item \il{host}, which takes a string and defaults to \il{'localhost'}.
	\item \il{db}, which takes a string and defaults to a backend-specific value.
	\item \il{port}, which takes an integer, and defaults to a backend-specific port.
\end{enumerate}
Our simple \il{FileModel}, then, uses the AppEngine backend, and will be stored locally, with default settings. Any subclasses of \il{FileModel}
will automatically inherit these settings, but fine control is possible by defining \il{_host, _db, _port} on the subclass in question.

Next, we set some fields that we think a \il{FileModel} should have:
\lstslice{17}{24}{model_definitions.py}
Notice that we don't \emph{initialize} any of the fields here - we're just defining what kind of \il{Field} each attribute should be.
Although QUI will store any attributes that an instance of \il{FileModel} may have (except private ones and callable ones), these
\il{Field} attributes will do run-time compatibility checking. For example:
\lstdump[Session 1][demonstrating run-time validation]{interpreter2.py}
Also, notice that you can still have ``regular'' class variables, like \il{class_var}; these will be stored by QUI just like all other non-callable
attributes.

Finally, we have a (pedantic) function definition, just to show that we can:
\lstslice{26}{28}{model_definitions.py}
Since \il{my_size} is a callable, QUI ignores it - but doesn't remove it from the model.
\lstdump[Session 2][using fields with functions]{interpreter1.py}

\subsection{Using QUI}
QUI's ease of use is best exhibited by entering the Python interpreter:
\lstdump[Session 3][getting and putting]{getting_and_setting.py}

\section{Language Design}

\subsection{Getting, Putting, and Creating}
The idea behind QUI is to support a uniform set of `verbs' across all backends. As an internal language focusing on storage, we implemented
these verbs as class methods and instance methods.

Since our time for this project was limited, we focused our efforts on what we saw as the three most important verbs for a persistent storage solution:
\begin{enumerate}
\item \textbf{Creating} an instance of a stored model, at run-time, on the fly, and having it stored into the backend.
\item \textbf{Putting} an instance of a stored model into the backend.
\item \textbf{Getting} an instance of a stored model from the data stored in the backend.
\end{enumerate}


\subsection{Syntax}
QUI strives for an optimal combination of clarity and concision. It achieves this by only officially exposing three extra methods on stored models: \il{get()}, \il{create()}, and \il{put()}.
\subsection{Semantic Abstractions/Building Blocks}

\section{Language Implementation}
\subsection{Host Language}
QUI is implemented in Python, which was chosen for three main reasons:
\begin{enumerate}
\item Our own familiarity with it.
\item Excellent metaprogramming facilities.
\item Availability of backend APIs
\end{enumerate}
\subsection{Parsing}
As an internal DSL, QUI doesn't do `parsing', in the same sense as an external one --- there's no need for an abstract syntax tree, and we can rely on Python to catch syntactically 
illegal expressions in many cases.
\subsection{Execution}
QUI executes as part of normal Python code.
\section{Evaluation}


\end{document}
